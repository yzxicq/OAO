
传统BIOS开机流程从你按下主机机壳上的电源键，到进入作业系统的期间，储存於主机板上那颗EEPROM（电气可抹除暨可程式化唯读记忆体）裡的BIOS便会开始执行以下的工作：
1. 初始化：当电脑打开，CPU会自行重置為初始状态，準备运作。BIOS boot block（基本输出输入系统开机区块）初始化阶段啟动，因為此时系统记忆体中是空的，没有内容可以执行，所以厂商让CPU去寻找系统BIOS ROM中的reset vector（重置向量）：用一个固定的位置来啟动所谓的BIOS boot program开机程式。一般来说程式会在记忆体的FFFF0h位址，也就是在UMA（上层记忆区域）靠结尾的地方。為避免ROM大小改变造成相容性的问题，所以一般会选择放这裡。它的内容只有一个jump指令，进一步跳到真正的BIOS啟动程序。当然了，各家IBV （independent BIOS vender；独立BIOS供应商）可以把程式放在不同的位置，只要透过jump来指定就可以了。在这段期间，系统的CPU、晶片组、Super I/O和USB只有部分初始化，仅获取足够资料来应付万一BIOS开机失败，可以利用软碟（由Super I/O控管）甚至是光碟（由晶片组的IDE/SATA）等储存媒体来救援BIOS的boot block。
2. POST（Power On Self Test；开机自我检测）：然后BIOS开始施行Power-On Self Test（POST；开机自我检测），在过程中检查电脑各项组件及其设定，像是：中央处理器、主记忆体、键盘、滑鼠等等状态。接著便寻找被内建在BIOS内部的显示卡程序并执行。它通常被放在记忆体C0000h的位置，作用是显示卡的初始化，而大部分的显示卡都会在显示器上显示其相关讯息。这就是為何各位在开机的时候，首先会在显示器的画面左上角出现有关显示卡讯息的原因。再下来就是让BIOS寻找其他装置的ROM（唯读记忆体），看看这些设备中哪些还有个别的BIOS。如果这时有找到任何其它装置的BIOS，它们也会被执行。下一步BIOS会显示啟动画面，并开始更深入的检测，包含我们平常可以在萤幕上看到的记忆体容量检测。如果这时候遇到任何错误，就会在画面上显示错误讯息。
3. 记录电脑系统的设定值：到这裡还没有结束，再来BIOS会根据自己的「系统资源表」，来对系统进行进一步的确认，看看你的电脑究竟安装了那些系统资源或设备。有些电脑会逐步显示这些被侦测到的设备。例如BIOS支援随插即用，那它将会侦测和配置随插即用装置，并显示由BIOS侦测到的随插即用设备。在这些检测结束后，BIOS会打出一个侦测总结表於画面上。而这个总结表在部分IBV的设定中是可以让使用者开啟或关闭的。当然也有些IBV為加速开机把这一步直接隐藏省略。Tips:BIOS boot block在快闪唯读记忆体内，通常会分成两个区块，一个区块存放一般的BIOS程式码，即所谓的code block（程式码区块）；另一个区块则是存放用来开机（或急救）的程式码，就是所谓的boot block（开机区块）。当电源打开时，主机板会先从boot block执行，它会立即检查code block 的程式码是否正确，如果正确，就会转到code block 继续执行下去。而所谓的BIOS recovery（BIOS回复）就是利用boot block回写动作来进行BIOS更新失败时的救援。
4. 提供常驻程式：提供作业系统或应用程式呼叫的中断向量，如INT 10h（VGA图形及文字输出中断）等。
5. 载入作业系统：到这裡是系统检测的部分，接下来BIOS便开始寻找开机装置，使用者可以透过在BIOS的设定来决定搜寻顺序，目前常见的开机设备至少包含FDD、HDD以及光碟机和USB开机装置等多项。找到开机装置后，BIOS将会搜寻开机讯息以进行作业系统的开机过程。如果是找到了一个灌好OS的硬碟，它将会寻找位在硬碟第0面，第0轨，第1磁区裡的Master Boot Record（主要开机磁区）。如果它找到的是FDD，也会读取软碟的第1磁区。再把读取到的资料放在记忆体7C00h的位置，跳到那裡并且执行它。自此才开始进入OS啟动阶段。
UEFI BIOS系统的开机流程
同样是进行电脑系统的开机，由於UEFI BIOS是遵循UEFI论坛的规范定义下开发的，所以UEFI的开机流程会像下图一般：
1. SEC阶段：SEC（安全性）阶段其主要的特色為「cache as RAM」，即处理器的快取当成记忆体。由於C语言需要使用堆叠，在这个阶段的系统记忆体尚未被初始化，在没有记忆体可用的情况下，便把处理器的快取当成记忆体来使用，在主记忆体被初始化之前来进行预先验证CPU／晶片组及主机板。因為这时侯没有快取，会导致处理器的效能变得较差，所以在记忆体初始化完毕之前，SEC和PEI阶段的程式码越简短，越能减少这个副作用。
2. PEI阶段：和传统BIOS的初始化阶段类似，PEI（EFI前初始化）阶段是用以唤醒CPU及记忆体初始化。这时候只起始了一小部分的记忆体。同时，晶片组和主机板也开始初始化。接下来的服务程式会确定CPU晶片组被正确的初始化，在此时，EFI驱动程式派送器将载入EFI驱动程式记忆体，进入了起始所有记忆体的DXE阶段（驱动程式执行环境）。
3. DXE阶段：DXE的主要功能在於沟通EFI驱动程式及硬体。也就是说此阶段所有的记忆体、CPU（在此是指实体两个或以上的非核心数目，也就是双CPU插槽处理器甚至是四CPU插槽处理器）、PCI、USB、SATA和Shell都会被初始化。
4. BDS阶段：在BDS（开机设备选择）这个阶段，使用者就可以自开机管理者程式页面，选择要从哪个侦测到的开机设备来啟动。
5. TSL阶段：然后进入TSL（短暂系统载入）阶段，由作业系统接手开机。除此之外，也可以在BDS阶段选择UEFI Shell，让系统进入简单的命令列，进行基本诊断和维护。传统BIOS哪裡不好？

在继续探讨何谓UEFI BIOS之前，先来看看传统BIOS有哪些问题，让Intel决心带头推出UEFI BIOS。
1. 过时的16位元模式在x86系列CPU进入32位元的时代，為了相容性考量，当时最新的80386 CPU保留了16位元的执行方式，即真实模式（real mode）。在后来多次的CPU改朝换代中都保留了这种执行方式，甚至在含有EM64T的Xeon系列CPU中，供电到CPU啟动时仍然会切换到16位元的真实模式下执行。也就是说，虽然各大BIOS厂商為了配合潮流演进，将许多新功能新元素添加到產品中，但BIOS在本质上没有任何改变。迫使Intel在开发更新的CPU时，都必须加进会使效能大大降低的相容模式。2. 只有1MB定址空间各位读者如果有注意传统BIOS开机，在POST完毕后萤幕上打出的系统摘要表，会发现记忆体栏位标示著「Base Memory=640KB」。加上前一篇提到的384KB UMA（这裡的记忆体不会列入Base Memory），就是所谓1MB可定址记忆体空间。会造成这项限制，主要还是真实模式的副作用。16位元的CPU，其定址能力為20条定址线所能处理的2^20位元组（Bytes），也就是1024千位元组（KB）。换句话说，在进入OS之前的开机阶段，即使安装了高达4GB的记忆体，绝大部分都无法使用。
3. 组合语言难维护假设某天你买了一张高阶工作站主机板，再装上一张SCSI或SAS的磁碟阵列卡，竟然发现安装后你的主机板开机开不下去，然后显示「Not enough space to copy PCI option ROM」或「Option ROM memory space exhausted」警告字串。然后本来你那雀跃快乐的心情消失了，取而代之的是「归LP火」熊熊燃烧著。当你打电话给阵列卡商，电话那头的死公务员声音说著：「你要不要问问主机板厂有没有新的BIOS？」。 好不容易找上主机板厂商客服问：「你们有没有办法解决？」然后，你和主机板BIOS工程师之间的攻防就此展开。对板卡厂的BIOS工程师而言，除非刚好有下单下很大的客户遇到类似相关问题，否则很有可能就是不了了之。你只好趁购买七天内退掉那张阵列卡，不然就是再找一张可以正常搭配的主机板。由於传统BIOS是用组合语言编写的，而软体界早就已经是C/C++高阶语言甚至是.NET满天飞，為了相对难找的人才（组合语言高手相对少，要BIOS真正写得好的更是少数）来减缓新產品上市的速度，不管是消费者或厂商都无法接受。此时UEFI BIOS标準化和模组化的特徵，便可加速產品推出和减少debug的时间。另外C语言写的UEFI BIOS体积也会变大，连带使储存BIOS的EEPROM需要扩增。别忘了，这也是Intel的势力范围，如果EFI BIOS推广成功，板卡厂就得多採购一颗晶片。

▲ 由於传统BIOS的先天侷限，有时候磁碟阵列卡就是装不上去。
4. 十年不变的程式码上述三大问题是以开发厂商的角度来观察。其他隐而不现的部分，则包含了功能的侷限性和对使用者不够友善的操作介面。对照现今的视窗介面作业系统，传统BIOS以文字介面為主且充满著火星文，加上除了单纯的开机，作為仲介硬体初始化和作业系统的功能外实在阳春的可怜。在开发Itanium CPU之际，业界大魔王Intel实在不想再受制於这些顾虑。试想，既然这是一个新生的CPU架构，那系统韧体和作业系统之间的介面就顺便一起重新定义。并且这一次，Intel為了让以后各种新的规格和技术可以快速导入，严格定义这个传统BIOS接班人必须具有扩展弹性，而且採取标準化的韧体介面规范，以避免发生传统BIOS的IBV程式码更新太被动的问题。笔者不是开玩笑，业界之前盛传一句话，如果Award BIOS当时（Intel Pentium处理器时代）没有华硕，那肯定没有后来功能齐全的BIOS程式编码。传统BIOS静态连结，缺乏远见且叠床架屋，而几乎全基於经验和约定的见招拆招。所以才有2000年开发出来所谓的EFI（Extensible Firmware Interface；可扩展韧体介面）技术作為工业标準规格，定义了一个驱动介面，用以沟通硬体／韧体和作业系统。UEFI的版本发展最初制定的EFI版本2000年12月的1.02版。在2002年的12月又释出了加入EFI驱动程式模型的1.10版。於2005年，Intel将此规格提供给负责UEFI开发和推广的UEFI论坛。為了反映这点，EFI也被更名為UEFI。在大部分的文件资料中，EFI和UEFI讲的是一样的东西。UEFI论坛在2007年1月释出2.1版的规范。目前最新公开的版本就是2009年5月发佈的2.3版。概括而论，凡依照UEFI论坛规范，使用C语言写作的BIOS即為UEFI BIOS。UEFI论坛成员类别IBV（独立BIOS 厂商）	AMI、Insyde、PhoenixIHV（独立硬体厂商）	AMD、Apple、Dell、HP、IBM、Intel、联想ISV（独立软体厂商）	微软UEFI BIOS哪裡好？UEFI是藉由UEFI论坛制定的严谨规范来达成标準化，并用模组化之C语言方式的参数堆叠传递，藉由动态连结形式所建构出来的系统，相较於使用组合语言的传统BIOS更易於实作，在容错和错误更正的表现上更加优良，更好开发。UEFI是以32或64位元CPU保护模式执行（也称為Flat Mode），突破传统16位元代码的定址能力，可达到CPU的最大定址空间。1. 定址空间更弹性UEFI BIOS利用载入EFI driver的形式，来进行硬体的辨识／控制及系统资源掌控。传统BIOS是以真实模式中断向量的方式增加硬体功能。它要将一段类似於驱动程式的16位元代码，放置在记忆体0x000C0000至0x000DFFFF之间。这段记忆体空间有限（128KB），因此，当必须放置的option ROM超过128KB时，传统BIOS便无能為力。很多时候传统BIOS的工程师為了解决这类问题，像刚刚提到的介面卡BIOS容量过大，便要想办法利用可能的排列组合硬挤出空间来放驱动代码。而重组过程有时不小心造成一些副作用，例如才刚解决的bug，重组后又再发生！也就是说，UEFI BIOS可以更有系统的分配储存空间，避免使用强制定址。2. 什麼系统都能用另外，传统BIOS的硬体服务程式都是以16位元代码的形式存在，在增强模式下执行的作业系统想存取这些服务会有困难。因此BIOS提供的服务在现实中只能提供给MS-DOS之类的系统用。相对的，UEFI系统下的驱动并不是可以直接在CPU执行的代码，而是用EBC（EFI Byte Code）这种专用於EFI driver的虚拟机器指令，该指令必须在UEFI的DXE阶段被解压缩后翻译执行。如此便有更佳的向下相容性，因為EFI driver是弹性的驱动程式模组架构，可不断的扩充驱动程式及介面，不用重新编写，所以就无需考虑因系统升级所衍生的相容性因素。3. 开发维护更容易加上EFI driver开发简单，所有的PC零组件厂商都可以参与，就像现代作业系统的开发模式，这样的模式曾使Windows系统短短几年就变得无比强大。有了EFI driver，也可以让显示卡在开机阶段就载入某种程度的功能，进而可以把传统文字介面為主的BIOS转成图形介面。4. 精简系统用途大最后还有EFI Shell，这是个精简的作业系统，可以让使用者进行BIOS的更新、系统诊断、安装特定软体。有了UEFI BIOS甚至可以播放CD和DVD而不需完全载入OS，EFI driver可以被载入或卸载，连TCP/IP核心程式都可以使用。基於EFI的driver model可使UEFI系统接触到所有的硬体功能，在进入作业系统之前瀏览网站不再是天方夜谭，甚至实作起来也非常简单。总之，对使用者而言，多了一个方便的环境以及华丽的图形介面，是最明显的好处。传统BIOS vs. UEFI BIOS重点差异BIOS种类	传统BIOS	UEFI BIOS程式语言	组合语言	C语言资源控制	中断向量写死的记忆体存取写死的输出／输入存取	驱动程式／协定处理器运行环境	X86 16位元	CPU保护模式扩充方式	接合中断向量	载入驱动程式第三方IHV和ISV支援性	较差	较佳且可以支援多平台图形化能力	较差	较佳内建简化的作业系统前环境	无	有有谁在用UEFI？UEFI支援必须藉由软硬体的相互合作来达成，我们来看看目前市面上流通的產品中，哪些已经採用了UEFI。支援UEFI的硬体1. 2006年，苹果电脑推出第一台使用Intel处理器架构的麦金塔电脑。从此开始用EFI/UEFI framework，而非以往搭载IBM PowerPC处理器的麦金塔电脑用的、发源於Sun Microsystems（昇阳电脑公司）的Open Firmware。▲ 目前新版的Mac OS X都已经支援UEFI。2. Intel自家的行动型、桌上型和伺服器电脑主机板自2006年起开始全面转换為EFI/UEFI BIOS。例如从945系列晶片组开始，Intel的主机板就已经使用了该framework。3. 此外，2008年开始，许多64位元电脑系统也正式支援EFI/UEFI BIOS。如IBM的x3450伺服器、微星科技具备ClickBIOS的主机板（包括下一篇介绍的EFINITY主机板）、HP笔记型电脑EliteBook系列和平板电脑、HP Compaq笔记型电脑较新的机种。▲ 微软到了Windows Server 2008才开始支援UEFI。支援UEFI的作业系统1. 早在2000年，Linux作业系统便可以支援EFI，当时是elilo EFIboot loader（开机载体），演化至今是EFI版本的grub。2. 苹果电脑到了Mac OS X 10.4（代号Tiger）的Intel版便可以支援EFI。3. 2002年微软给Itanium CPU使用的Windows 2000 Advanced Server Limited Edition及Datacenter Server Limited Edition版支援了EFI v1.10规范。后来的Windows Server 2003 for IA-64版和Windows XP 64-bit版本也支援EFI。至於UEFI的支援是从Windows Server 2008和Vista SP1的64位元版本开始，包括Windows 7也只有64位元版完整支援UEFI。▲ Intel自家的D945PSN主机板。综上所述：BIOS开机：上电---初始化---自检---载入开机程式---开机；UEFI开机：上电先加载EFI微型操作系统；应用软件，驱动程序，硬件构成；最后加载作业系统windows；
